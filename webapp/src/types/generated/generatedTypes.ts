/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/status": {
    /** Get the status of the app */
    get: operations["get_status_status_get"];
  };
  "/dataset_info": {
    /** Get the current dataset info */
    get: operations["get_dataset_info_dataset_info_get"];
  };
  "/custom_metrics_info": {
    /** Gives the description of all custom metrics. */
    get: operations["custom_metrics_info_custom_metrics_info_get"];
  };
  "/perturbation_testing_summary": {
    /** Get a failure rate per dataset split and per test as well. */
    get: operations["get_perturbation_testing_summary_perturbation_testing_summary_get"];
  };
  "/admin/default_config": {
    /** Get the default configuration */
    get: operations["get_default_config_def_admin_default_config_get"];
  };
  "/admin/config": {
    /** Get the current configuration */
    get: operations["get_config_def_admin_config_get"];
    /** Update the config. */
    patch: operations["patch_config_admin_config_patch"];
  };
  "/dataset_splits/{dataset_split_name}/class_overlap/plot": {
    /** Get a plot of class overlap using Spectral clustering and Monte-Carlo sampling (currently set to all samples). */
    get: operations["get_class_overlap_plot_dataset_splits__dataset_split_name__class_overlap_plot_get"];
  };
  "/dataset_splits/{dataset_split_name}/class_overlap": {
    /** Get data for class overlap, confusion, and related utterance counts. */
    get: operations["get_class_overlap_dataset_splits__dataset_split_name__class_overlap_get"];
  };
  "/dataset_splits/{dataset_split_name}/confidence_histogram": {
    /** Get all confidence bins with their confidence and the outcome count */
    get: operations["get_confidence_histogram_dataset_splits__dataset_split_name__confidence_histogram_get"];
  };
  "/dataset_warnings": {
    /** Get the warnings related to the dataset, such as differences between the training and the evaluation set. */
    get: operations["get_dataset_warnings_dataset_warnings_get"];
  };
  "/dataset_splits/{dataset_split_name}/metrics": {
    /** Get metrics (ECE, outcome count, precision and so on). */
    get: operations["get_metrics_dataset_splits__dataset_split_name__metrics_get"];
  };
  "/dataset_splits/{dataset_split_name}/metrics/per_filter": {
    /** Get metrics for each filter based on the current filtering. */
    get: operations["get_metrics_per_filter_dataset_splits__dataset_split_name__metrics_per_filter_get"];
  };
  "/dataset_splits/{dataset_split_name}/outcome_count/per_threshold": {
    /** Get prediction count per outcome for multiple thresholds. */
    get: operations["get_outcome_count_per_threshold_dataset_splits__dataset_split_name__outcome_count_per_threshold_get"];
  };
  "/dataset_splits/{dataset_split_name}/outcome_count/per_filter": {
    /** Get outcome count for each filter based on the current filtering. */
    get: operations["get_outcome_count_per_filter_dataset_splits__dataset_split_name__outcome_count_per_filter_get"];
  };
  "/dataset_splits/{dataset_split_name}/utterance_count/per_filter": {
    /** Get count for each filter based on the current filtering. */
    get: operations["get_count_per_filter_dataset_splits__dataset_split_name__utterance_count_per_filter_get"];
  };
  "/dataset_splits/{dataset_split_name}/utterances": {
    /** Get a table view of the utterances according to filters. */
    get: operations["get_utterances_dataset_splits__dataset_split_name__utterances_get"];
    /** Patch utterances, such as updating proposed actions. */
    post: operations["patch_utterances_dataset_splits__dataset_split_name__utterances_post"];
  };
  "/dataset_splits/{dataset_split_name}/utterances/{index}/perturbed_utterances": {
    /** Get a perturbed utterances for a single utterance. */
    get: operations["get_perturbed_utterances_dataset_splits__dataset_split_name__utterances__index__perturbed_utterances_get"];
  };
  "/dataset_splits/{dataset_split_name}/utterances/{index}/similar_utterances": {
    /** Get similar examples using a KNN approach. */
    get: operations["get_similar_dataset_splits__dataset_split_name__utterances__index__similar_utterances_get"];
  };
  "/export/dataset_splits/{dataset_split_name}/utterances": {
    /** Export the dataset_split to a CSV file and returns it. */
    get: operations["export_dataset_export_dataset_splits__dataset_split_name__utterances_get"];
  };
  "/export/dataset_splits/{dataset_split_name}/proposed_actions": {
    /** Export proposed actions to a CSV file and returns it. */
    get: operations["export_proposed_actions_export_dataset_splits__dataset_split_name__proposed_actions_get"];
  };
  "/export/perturbation_testing_summary": {
    /** Export the perturbation testing summary to a CSV file and returns it. */
    get: operations["get_export_perturbation_testing_summary_export_perturbation_testing_summary_get"];
  };
  "/export/dataset_splits/{dataset_split_name}/perturbed_utterances": {
    /** Export the perturbed dataset split (training or evaluation) to a JSON file and returns it. */
    get: operations["get_export_perturbed_set_export_dataset_splits__dataset_split_name__perturbed_utterances_get"];
  };
  "/custom_utterances/perturbed_utterances": {
    /** Get perturbed utterances based on custom utterances. */
    get: operations["get_perturbed_utterances_custom_utterances_perturbed_utterances_get"];
  };
  "/custom_utterances/saliency": {
    /** Get saliency for custom utterances. */
    get: operations["get_saliency_custom_utterances_saliency_get"];
  };
  "/dataset_splits/{dataset_split_name}/top_words": {
    /** Get most important words for right predictions and errors based on filters. */
    get: operations["get_top_words_dataset_splits__dataset_split_name__top_words_get"];
  };
  "/dataset_splits/{dataset_split_name}/confusion_matrix": {
    /** Get confusion matrix on specified filters. */
    get: operations["get_confusion_matrix_dataset_splits__dataset_split_name__confusion_matrix_get"];
  };
}

export interface components {
  schemas: {
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    AvailableDatasetSplits: {
      train: boolean;
      eval: boolean;
    };
    /** Fields that can be modified without affecting caching. */
    AzimuthConfig: {
      name: string;
      dataset: components["schemas"]["CustomObject"];
      columns: components["schemas"]["ColumnConfiguration"];
      rejection_class: string | null;
      artifact_path: string;
      batch_size: number;
      use_cuda: "auto" | boolean;
      large_dask_cluster: boolean;
      read_only_config: boolean;
      dataset_warnings: components["schemas"]["DatasetWarningsOptions"];
      model_contract: components["schemas"]["SupportedModelContract"];
      pipelines: components["schemas"]["PipelineDefinition"][] | null;
      uncertainty: components["schemas"]["UncertaintyOptions"];
      saliency_layer: string | null;
      syntax: components["schemas"]["SyntaxOptions"];
      metrics: { [key: string]: components["schemas"]["MetricDefinition"] };
      language: components["schemas"]["SupportedLanguage"];
      similarity: components["schemas"]["SimilarityOptions"] | null;
      behavioral_testing:
        | components["schemas"]["BehavioralTestingOptions"]
        | null;
    };
    /**
     * Base class for settings, allowing values to be overridden by environment variables.
     *
     * This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),
     * Heroku and any 12 factor app design.
     */
    BehavioralTestingOptions: {
      neutral_token: components["schemas"]["NeutralTokenOptions"];
      punctuation: components["schemas"]["PunctuationTestOptions"];
      fuzzy_matching: components["schemas"]["FuzzyMatchingTestOptions"];
      typo: components["schemas"]["TypoTestOptions"];
      seed: number;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    ClassOverlapPlotResponse: {
      plot: components["schemas"]["PlotSpecification"];
      defaultOverlapThreshold: number;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    ClassOverlapTableClassPair: {
      sourceClass: string;
      targetClass: string;
      overlapScoreTrain: number;
      pipelineConfusionEval: number | null;
      utteranceCountSourceTrain: number;
      utteranceCountSourceEval: number;
      utteranceCountWithOverlapTrain: number;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    ClassOverlapTableResponse: {
      classPairs: components["schemas"]["ClassOverlapTableClassPair"][];
    };
    /**
     * Base class for settings, allowing values to be overridden by environment variables.
     *
     * This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),
     * Heroku and any 12 factor app design.
     */
    ColumnConfiguration: {
      text_input: string;
      raw_text_input: string;
      label: string;
      failed_parsing_reason: string;
      persistent_id: string;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    ConfidenceBinDetails: {
      binIndex: number;
      binConfidence: number;
      meanBinConfidence: number;
      outcomeCount: { [key: string]: number };
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    ConfidenceHistogramResponse: {
      bins: components["schemas"]["ConfidenceBinDetails"][];
      confidenceThreshold: number | null;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    ConfusionMatrixResponse: {
      confusionMatrix: { [key: string]: any };
      classNames: string[];
      normalize: boolean;
      reorderClasses: boolean;
      rejectionClass: string;
    };
    /**
     * Base class for settings, allowing values to be overridden by environment variables.
     *
     * This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),
     * Heroku and any 12 factor app design.
     */
    CustomObject: {
      /** Name of the function or class that is located in `remote`.`args` and `kwargs` will be sent to the function/class. */
      class_name: string;
      args: { [key: string]: any }[];
      kwargs: { [key: string]: any };
      /** Absolute path to class. `class_name` needs to be accessible from this path. */
      remote: string | null;
    };
    /** An enumeration. */
    DataAction:
      | "relabel"
      | "augment_with_similar"
      | "define_new_class"
      | "merge_classes"
      | "remove"
      | "investigate"
      | "NO_ACTION";
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    DatasetDistributionComparison: {
      name: string;
      alert: boolean;
      data: components["schemas"]["DatasetDistributionComparisonValue"][];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    DatasetDistributionComparisonValue: {
      value: (number | number) | null;
      alert: boolean;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    DatasetInfoResponse: {
      projectName: string;
      classNames: string[];
      dataActions: components["schemas"]["DataAction"][];
      smartTags: components["schemas"]["SmartTag"][];
      evalClassDistribution: number[];
      trainClassDistribution: number[];
      startupTasks: { [key: string]: any };
      modelContract: components["schemas"]["SupportedModelContract"];
      predictionAvailable: boolean;
      perturbationTestingAvailable: boolean;
      availableDatasetSplits: components["schemas"]["AvailableDatasetSplits"];
      similarityAvailable: boolean;
      postprocessingEditable: boolean[] | null;
    };
    /** An enumeration. */
    DatasetSplitName: "eval" | "train" | "all";
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    DatasetWarning: {
      name: string;
      description: string;
      columns: string[];
      format: components["schemas"]["FormatType"];
      comparisons: components["schemas"]["DatasetDistributionComparison"][];
      plots: components["schemas"]["DatasetWarningPlots"];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    DatasetWarningGroup: {
      name: string;
      warnings: components["schemas"]["DatasetWarning"][];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    DatasetWarningPlots: {
      overall: components["schemas"]["PlotSpecification"];
      perClass: {
        [key: string]: components["schemas"]["PlotSpecification"];
      } | null;
    };
    /**
     * Base class for settings, allowing values to be overridden by environment variables.
     *
     * This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),
     * Heroku and any 12 factor app design.
     */
    DatasetWarningsOptions: {
      min_num_per_class: number;
      max_delta_class_imbalance: number;
      max_delta_representation: number;
      max_delta_mean_words: number;
      max_delta_std_words: number;
    };
    /** An enumeration. */
    FormatType: "Integer" | "Percentage" | "Decimal";
    /**
     * Base class for settings, allowing values to be overridden by environment variables.
     *
     * This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),
     * Heroku and any 12 factor app design.
     */
    FuzzyMatchingTestOptions: {
      threshold: number;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    GetUtterancesResponse: {
      utterances: components["schemas"]["Utterance"][];
      utteranceCount: number;
      confidenceThreshold: number | null;
    };
    HTTPValidationError: {
      detail?: components["schemas"]["ValidationError"][];
    };
    /**
     * Base class for settings, allowing values to be overridden by environment variables.
     *
     * This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),
     * Heroku and any 12 factor app design.
     */
    MetricDefinition: {
      /** Name of the function or class that is located in `remote`.`args` and `kwargs` will be sent to the function/class. */
      class_name: string;
      args: { [key: string]: any }[];
      kwargs: { [key: string]: any };
      /** Absolute path to class. `class_name` needs to be accessible from this path. */
      remote: string | null;
      /** Keyword arguments supplied to `compute`. */
      additional_kwargs: { [key: string]: any };
    };
    MetricInfo: {
      description: string;
      citation: string;
      features: { [key: string]: any };
      inputs_description: string;
      homepage: string;
      license: string;
      codebase_urls: string[];
      reference_urls: string[];
      streamable?: boolean;
      format?: string;
      metric_name?: string;
      config_name?: string;
      experiment_id?: string;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    MetricsAPIResponse: {
      outcomeCount: { [key: string]: number };
      utteranceCount: number;
      customMetrics: { [key: string]: number };
      ece: number;
      ecePlot: components["schemas"]["PlotSpecification"] | null;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    MetricsPerFilter: {
      almostCorrect: components["schemas"]["MetricsPerFilterValue"][];
      behavioralTesting: components["schemas"]["MetricsPerFilterValue"][];
      pipelineComparison: components["schemas"]["MetricsPerFilterValue"][];
      uncertain: components["schemas"]["MetricsPerFilterValue"][];
      extremeLength: components["schemas"]["MetricsPerFilterValue"][];
      partialSyntax: components["schemas"]["MetricsPerFilterValue"][];
      dissimilar: components["schemas"]["MetricsPerFilterValue"][];
      label: components["schemas"]["MetricsPerFilterValue"][];
      prediction: components["schemas"]["MetricsPerFilterValue"][];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    MetricsPerFilterAPIResponse: {
      metricsPerFilter: components["schemas"]["MetricsPerFilter"];
      utteranceCount: number;
      metricsOverall: components["schemas"]["MetricsPerFilterValue"][];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    MetricsPerFilterValue: {
      utteranceCount: number;
      filterValue: string;
      outcomeCount: { [key: string]: number };
      customMetrics: { [key: string]: number };
      ece: number;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    ModelPrediction: {
      modelPredictions: string[];
      postprocessedPrediction: string;
      modelConfidences: number[];
      postprocessedConfidences: number[];
      modelOutcome: components["schemas"]["OutcomeName"];
      postprocessedOutcome: components["schemas"]["OutcomeName"];
      preprocessingSteps: components["schemas"]["PreprocessingStepAPIResponse"][];
      postprocessingSteps: components["schemas"]["PostprocessingStepAPIResponse"][];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    ModelSaliency: {
      tokens: string[];
      saliencies: number[];
    };
    /**
     * Base class for settings, allowing values to be overridden by environment variables.
     *
     * This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),
     * Heroku and any 12 factor app design.
     */
    NeutralTokenOptions: {
      threshold: number;
      suffix_list: string[];
      prefix_list: string[];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    OutcomeCountPerFilter: {
      almostCorrect: components["schemas"]["OutcomeCountPerFilterValue"][];
      behavioralTesting: components["schemas"]["OutcomeCountPerFilterValue"][];
      pipelineComparison: components["schemas"]["OutcomeCountPerFilterValue"][];
      uncertain: components["schemas"]["OutcomeCountPerFilterValue"][];
      prediction: components["schemas"]["OutcomeCountPerFilterValue"][];
      outcome: components["schemas"]["OutcomeCountPerFilterValue"][];
      extremeLength: components["schemas"]["OutcomeCountPerFilterValue"][];
      partialSyntax: components["schemas"]["OutcomeCountPerFilterValue"][];
      dissimilar: components["schemas"]["OutcomeCountPerFilterValue"][];
      label: components["schemas"]["OutcomeCountPerFilterValue"][];
      dataAction: components["schemas"]["OutcomeCountPerFilterValue"][];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    OutcomeCountPerFilterResponse: {
      countPerFilter: components["schemas"]["OutcomeCountPerFilter"];
      utteranceCount: number;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    OutcomeCountPerFilterValue: {
      utteranceCount: number;
      filterValue: string;
      outcomeCount: { [key: string]: number };
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    OutcomeCountPerThresholdValue: {
      threshold: number;
      outcomeCount: { [key: string]: number };
    };
    /** An enumeration. */
    OutcomeName:
      | "CorrectAndPredicted"
      | "CorrectAndRejected"
      | "IncorrectAndPredicted"
      | "IncorrectAndRejected";
    /** An enumeration. */
    PerturbationTestFailureReason:
      | "Different predicted class."
      | "Confidence too far from original."
      | "NA";
    /** An enumeration. */
    PerturbationTestFamily: "Fuzzy Matching" | "Punctuation";
    /** An enumeration. */
    PerturbationTestName:
      | "Neutral Token"
      | "Question Mark"
      | "Ending Period"
      | "Inner Comma"
      | "Inner Period"
      | "Typos"
      | "Contractions";
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    PerturbationTestSummary: {
      name: components["schemas"]["PerturbationTestName"];
      description: string;
      family: components["schemas"]["PerturbationTestFamily"];
      perturbationType: components["schemas"]["PerturbationType"];
      evalFailureRate: number;
      evalCount: number;
      evalFailedCount: number;
      evalConfidenceDelta: number;
      trainFailureRate: number;
      trainCount: number;
      trainFailedCount: number;
      trainConfidenceDelta: number;
      example: components["schemas"]["PerturbedUtteranceExample"];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    PerturbationTestingSummary: {
      allTestsSummary: components["schemas"]["PerturbationTestSummary"][];
      failureRates: { [key: string]: number };
    };
    /** An enumeration. */
    PerturbationType:
      | "PreInsertion"
      | "PostInsertion"
      | "Deletion"
      | "Insertion"
      | "Replacement"
      | "Swap"
      | "Expansion"
      | "Contraction";
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    PerturbedUtteranceExample: {
      utterance: string;
      perturbedUtterance: string;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    PerturbedUtteranceWithClassNames: {
      name: components["schemas"]["PerturbationTestName"];
      description: string;
      family: components["schemas"]["PerturbationTestFamily"];
      perturbedUtterance: string;
      perturbations: string[];
      perturbationType: components["schemas"]["PerturbationType"];
      confidence: number;
      confidenceDelta: number | null;
      failed: boolean;
      failureReason: components["schemas"]["PerturbationTestFailureReason"];
      prediction: string;
    };
    /**
     * Base class for settings, allowing values to be overridden by environment variables.
     *
     * This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),
     * Heroku and any 12 factor app design.
     */
    PipelineDefinition: {
      name: string;
      model: components["schemas"]["CustomObject"];
      postprocessors:
        | (
            | components["schemas"]["TemperatureScaling"]
            | components["schemas"]["ThresholdConfig"]
            | components["schemas"]["CustomObject"]
          )[]
        | null;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    PlotSpecification: {
      data: { [key: string]: any }[];
      layout: { [key: string]: any };
    };
    /** Class for saving the results in the dataset and the routes. */
    PostprocessingStepAPIResponse: {
      output: components["schemas"]["PredictionDetails"];
      className: string;
    };
    /**
     * Details of the predictions.
     *
     * Args:
     *     predictions: Prediction class names, sorted by confidences
     *     prediction: Predicted class, which can be different than the first element of predictions,
     *         when thresholding for instance.
     *     confidences: Sorted confidences
     *     outcome: Outcome based on label and prediction
     */
    PredictionDetails: {
      predictions: string[];
      prediction: string;
      confidences: number[];
      outcome: components["schemas"]["OutcomeName"];
    };
    /** Class for saving the results in the dataset and the routes. */
    PreprocessingStepAPIResponse: {
      text: string;
      className: string;
    };
    /**
     * Base class for settings, allowing values to be overridden by environment variables.
     *
     * This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),
     * Heroku and any 12 factor app design.
     */
    PunctuationTestOptions: {
      threshold: number;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    SaliencyResponse: {
      saliency: number[];
      tokens: string[];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    SimilarUtterance: {
      persistentId: number | string;
      /** Row index created by Azimuth */
      index: number;
      utterance: string;
      label: string;
      postprocessedPrediction: string | null;
      postprocessedConfidence: number | null;
      similarity: number;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    SimilarUtterancesResponse: {
      utterances: components["schemas"]["SimilarUtterance"][];
    };
    /**
     * Base class for settings, allowing values to be overridden by environment variables.
     *
     * This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),
     * Heroku and any 12 factor app design.
     */
    SimilarityOptions: {
      faiss_encoder: string;
      conflicting_neighbors_threshold: number;
      no_close_threshold: number;
    };
    /** An enumeration. */
    SmartTag:
      | "multiple_sentences"
      | "long_utterance"
      | "short_utterance"
      | "missing_subj"
      | "missing_obj"
      | "missing_verb"
      | "conflicting_neighbors_train"
      | "conflicting_neighbors_eval"
      | "no_close_train"
      | "no_close_eval"
      | "failed_punctuation"
      | "failed_fuzzy_matching"
      | "high_epistemic_uncertainty"
      | "correct_top_3"
      | "correct_low_conf"
      | "incorrect_for_all_pipelines"
      | "pipeline_disagreement"
      | "NO_SMART_TAGS";
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    StatusResponse: {
      startupTasksReady: boolean;
      startupTasksStatus: { [key: string]: string };
    };
    /** An enumeration. */
    SupportedLanguage: "en" | "fr";
    /** An enumeration. */
    SupportedModelContract:
      | "hf_text_classification"
      | "file_based_text_classification"
      | "custom_text_classification";
    /** An enumeration. */
    SupportedSpacyModels: "" | "en_core_web_sm" | "fr_core_news_md";
    /**
     * Base class for settings, allowing values to be overridden by environment variables.
     *
     * This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),
     * Heroku and any 12 factor app design.
     */
    SyntaxOptions: {
      short_utterance_max_word: number;
      long_utterance_min_word: number;
      spacy_model: components["schemas"]["SupportedSpacyModels"];
      subj_tags: string[];
      obj_tags: string[];
    };
    /**
     * Base class for settings, allowing values to be overridden by environment variables.
     *
     * This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),
     * Heroku and any 12 factor app design.
     */
    TemperatureScaling: {
      class_name: "azimuth.utils.ml.postprocessing.TemperatureScaling";
      args: { [key: string]: any }[];
      kwargs: { [key: string]: any };
      /** Absolute path to class. `class_name` needs to be accessible from this path. */
      remote: string | null;
      temperature: number;
    };
    /**
     * Base class for settings, allowing values to be overridden by environment variables.
     *
     * This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),
     * Heroku and any 12 factor app design.
     */
    ThresholdConfig: {
      class_name: "azimuth.utils.ml.postprocessing.Thresholding";
      args: { [key: string]: any }[];
      kwargs: { [key: string]: any };
      /** Absolute path to class. `class_name` needs to be accessible from this path. */
      remote: string | null;
      threshold: number;
    };
    /** An enumeration. */
    TopWordsImportanceCriteria: "salient" | "frequent";
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    TopWordsResponse: {
      all: components["schemas"]["TopWordsResult"][];
      right: components["schemas"]["TopWordsResult"][];
      errors: components["schemas"]["TopWordsResult"][];
      importanceCriteria: components["schemas"]["TopWordsImportanceCriteria"];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    TopWordsResult: {
      word: string;
      count: number;
    };
    /**
     * Base class for settings, allowing values to be overridden by environment variables.
     *
     * This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),
     * Heroku and any 12 factor app design.
     */
    TypoTestOptions: {
      threshold: number;
      nb_typos_per_utterance: number;
    };
    /**
     * Base class for settings, allowing values to be overridden by environment variables.
     *
     * This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),
     * Heroku and any 12 factor app design.
     */
    UncertaintyOptions: {
      iterations: number;
      high_epistemic_threshold: number;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    Utterance: {
      persistentId: number | string;
      /** Row index created by Azimuth */
      index: number;
      utterance: string;
      label: string;
      dataAction: components["schemas"]["DataAction"];
      almostCorrect: string[];
      behavioralTesting: string[];
      pipelineComparison: string[];
      uncertain: string[];
      extremeLength: string[];
      partialSyntax: string[];
      dissimilar: string[];
      modelPrediction: components["schemas"]["ModelPrediction"] | null;
      modelSaliency: components["schemas"]["ModelSaliency"] | null;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    UtteranceCountPerFilter: {
      extremeLength: components["schemas"]["UtteranceCountPerFilterValue"][];
      partialSyntax: components["schemas"]["UtteranceCountPerFilterValue"][];
      dissimilar: components["schemas"]["UtteranceCountPerFilterValue"][];
      label: components["schemas"]["UtteranceCountPerFilterValue"][];
      dataAction: components["schemas"]["UtteranceCountPerFilterValue"][];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    UtteranceCountPerFilterResponse: {
      countPerFilter: components["schemas"]["UtteranceCountPerFilter"];
      utteranceCount: number;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    UtteranceCountPerFilterValue: {
      utteranceCount: number;
      filterValue: string;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    UtterancePatch: {
      persistentId: number | string;
      dataAction: components["schemas"]["DataAction"];
    };
    /** An enumeration. */
    UtterancesSortableColumn:
      | "index"
      | "utterance"
      | "label"
      | "prediction"
      | "confidence";
    ValidationError: {
      loc: string[];
      msg: string;
      type: string;
    };
  };
}

export interface operations {
  /** Get the status of the app */
  get_status_status_get: {
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["StatusResponse"];
        };
      };
    };
  };
  /** Get the current dataset info */
  get_dataset_info_dataset_info_get: {
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["DatasetInfoResponse"];
        };
      };
    };
  };
  /** Gives the description of all custom metrics. */
  custom_metrics_info_custom_metrics_info_get: {
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": {
            [key: string]: components["schemas"]["MetricInfo"];
          };
        };
      };
    };
  };
  /** Get a failure rate per dataset split and per test as well. */
  get_perturbation_testing_summary_perturbation_testing_summary_get: {
    parameters: {
      query: {
        pipeline_index: number;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PerturbationTestingSummary"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get the default configuration */
  get_default_config_def_admin_default_config_get: {
    parameters: {
      query: {
        language?: components["schemas"]["SupportedLanguage"];
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["AzimuthConfig"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get the current configuration */
  get_config_def_admin_config_get: {
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["AzimuthConfig"];
        };
      };
    };
  };
  /** Update the config. */
  patch_config_admin_config_patch: {
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["AzimuthConfig"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": { [key: string]: any };
      };
    };
  };
  /** Get a plot of class overlap using Spectral clustering and Monte-Carlo sampling (currently set to all samples). */
  get_class_overlap_plot_dataset_splits__dataset_split_name__class_overlap_plot_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
      query: {
        /** Whether to include overlap of a class with itself. */
        self_overlap?: boolean;
        /** Whether to scale overlap values by class sample counts. */
        scale_by_class?: boolean;
        /** Plot overlap greater than this value (`None` sets threshold to show ~10 class pairs). */
        overlap_threshold?: number;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ClassOverlapPlotResponse"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get data for class overlap, confusion, and related utterance counts. */
  get_class_overlap_dataset_splits__dataset_split_name__class_overlap_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
      query: {
        pipeline_index?: number;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ClassOverlapTableResponse"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get all confidence bins with their confidence and the outcome count */
  get_confidence_histogram_dataset_splits__dataset_split_name__confidence_histogram_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
      query: {
        without_postprocessing?: boolean;
        pipeline_index: number;
        confidence_min?: number;
        confidence_max?: number;
        label?: string[];
        prediction?: string[];
        extreme_length?: components["schemas"]["SmartTag"][];
        partial_syntax?: components["schemas"]["SmartTag"][];
        dissimilar?: components["schemas"]["SmartTag"][];
        almost_correct?: components["schemas"]["SmartTag"][];
        behavioral_testing?: components["schemas"]["SmartTag"][];
        pipeline_comparison?: components["schemas"]["SmartTag"][];
        uncertain?: components["schemas"]["SmartTag"][];
        data_action?: components["schemas"]["DataAction"][];
        outcome?: components["schemas"]["OutcomeName"][];
        utterance?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ConfidenceHistogramResponse"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get the warnings related to the dataset, such as differences between the training and the evaluation set. */
  get_dataset_warnings_dataset_warnings_get: {
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["DatasetWarningGroup"][];
        };
      };
    };
  };
  /** Get metrics (ECE, outcome count, precision and so on). */
  get_metrics_dataset_splits__dataset_split_name__metrics_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
      query: {
        without_postprocessing?: boolean;
        pipeline_index: number;
        confidence_min?: number;
        confidence_max?: number;
        label?: string[];
        prediction?: string[];
        extreme_length?: components["schemas"]["SmartTag"][];
        partial_syntax?: components["schemas"]["SmartTag"][];
        dissimilar?: components["schemas"]["SmartTag"][];
        almost_correct?: components["schemas"]["SmartTag"][];
        behavioral_testing?: components["schemas"]["SmartTag"][];
        pipeline_comparison?: components["schemas"]["SmartTag"][];
        uncertain?: components["schemas"]["SmartTag"][];
        data_action?: components["schemas"]["DataAction"][];
        outcome?: components["schemas"]["OutcomeName"][];
        utterance?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["MetricsAPIResponse"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get metrics for each filter based on the current filtering. */
  get_metrics_per_filter_dataset_splits__dataset_split_name__metrics_per_filter_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
      query: {
        pipeline_index: number;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["MetricsPerFilterAPIResponse"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get prediction count per outcome for multiple thresholds. */
  get_outcome_count_per_threshold_dataset_splits__dataset_split_name__outcome_count_per_threshold_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
      query: {
        pipeline_index: number;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["OutcomeCountPerThresholdValue"][];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get outcome count for each filter based on the current filtering. */
  get_outcome_count_per_filter_dataset_splits__dataset_split_name__outcome_count_per_filter_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
      query: {
        without_postprocessing?: boolean;
        pipeline_index: number;
        confidence_min?: number;
        confidence_max?: number;
        label?: string[];
        prediction?: string[];
        extreme_length?: components["schemas"]["SmartTag"][];
        partial_syntax?: components["schemas"]["SmartTag"][];
        dissimilar?: components["schemas"]["SmartTag"][];
        almost_correct?: components["schemas"]["SmartTag"][];
        behavioral_testing?: components["schemas"]["SmartTag"][];
        pipeline_comparison?: components["schemas"]["SmartTag"][];
        uncertain?: components["schemas"]["SmartTag"][];
        data_action?: components["schemas"]["DataAction"][];
        outcome?: components["schemas"]["OutcomeName"][];
        utterance?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["OutcomeCountPerFilterResponse"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get count for each filter based on the current filtering. */
  get_count_per_filter_dataset_splits__dataset_split_name__utterance_count_per_filter_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
      query: {
        confidence_min?: number;
        confidence_max?: number;
        label?: string[];
        prediction?: string[];
        extreme_length?: components["schemas"]["SmartTag"][];
        partial_syntax?: components["schemas"]["SmartTag"][];
        dissimilar?: components["schemas"]["SmartTag"][];
        almost_correct?: components["schemas"]["SmartTag"][];
        behavioral_testing?: components["schemas"]["SmartTag"][];
        pipeline_comparison?: components["schemas"]["SmartTag"][];
        uncertain?: components["schemas"]["SmartTag"][];
        data_action?: components["schemas"]["DataAction"][];
        outcome?: components["schemas"]["OutcomeName"][];
        utterance?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UtteranceCountPerFilterResponse"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get a table view of the utterances according to filters. */
  get_utterances_dataset_splits__dataset_split_name__utterances_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
      query: {
        indices?: number[];
        sort?: components["schemas"]["UtterancesSortableColumn"];
        descending?: boolean;
        without_postprocessing?: boolean;
        confidence_min?: number;
        confidence_max?: number;
        label?: string[];
        prediction?: string[];
        extreme_length?: components["schemas"]["SmartTag"][];
        partial_syntax?: components["schemas"]["SmartTag"][];
        dissimilar?: components["schemas"]["SmartTag"][];
        almost_correct?: components["schemas"]["SmartTag"][];
        behavioral_testing?: components["schemas"]["SmartTag"][];
        pipeline_comparison?: components["schemas"]["SmartTag"][];
        uncertain?: components["schemas"]["SmartTag"][];
        data_action?: components["schemas"]["DataAction"][];
        outcome?: components["schemas"]["OutcomeName"][];
        utterance?: string;
        pipeline_index?: number;
        limit?: number;
        offset?: number;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["GetUtterancesResponse"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Patch utterances, such as updating proposed actions. */
  patch_utterances_dataset_splits__dataset_split_name__utterances_post: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UtterancePatch"][];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UtterancePatch"][];
      };
    };
  };
  /** Get a perturbed utterances for a single utterance. */
  get_perturbed_utterances_dataset_splits__dataset_split_name__utterances__index__perturbed_utterances_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
        index: number;
      };
      query: {
        pipeline_index: number;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PerturbedUtteranceWithClassNames"][];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get similar examples using a KNN approach. */
  get_similar_dataset_splits__dataset_split_name__utterances__index__similar_utterances_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
        index: number;
      };
      query: {
        limit?: number;
        neighbors_dataset_split_name?: components["schemas"]["DatasetSplitName"];
        pipeline_index?: number;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["SimilarUtterancesResponse"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Export the dataset_split to a CSV file and returns it. */
  export_dataset_export_dataset_splits__dataset_split_name__utterances_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
      query: {
        pipeline_index?: number;
      };
    };
    responses: {
      /** Successful Response */
      200: unknown;
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Export proposed actions to a CSV file and returns it. */
  export_proposed_actions_export_dataset_splits__dataset_split_name__proposed_actions_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
    };
    responses: {
      /** Successful Response */
      200: unknown;
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Export the perturbation testing summary to a CSV file and returns it. */
  get_export_perturbation_testing_summary_export_perturbation_testing_summary_get: {
    parameters: {
      query: {
        pipeline_index: number;
      };
    };
    responses: {
      /** Successful Response */
      200: unknown;
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Export the perturbed dataset split (training or evaluation) to a JSON file and returns it. */
  get_export_perturbed_set_export_dataset_splits__dataset_split_name__perturbed_utterances_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
      query: {
        pipeline_index: number;
      };
    };
    responses: {
      /** Successful Response */
      200: unknown;
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get perturbed utterances based on custom utterances. */
  get_perturbed_utterances_custom_utterances_perturbed_utterances_get: {
    parameters: {
      query: {
        utterances?: string[];
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": { [key: string]: any };
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get saliency for custom utterances. */
  get_saliency_custom_utterances_saliency_get: {
    parameters: {
      query: {
        utterances?: string[];
        pipeline_index: number;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["SaliencyResponse"][];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get most important words for right predictions and errors based on filters. */
  get_top_words_dataset_splits__dataset_split_name__top_words_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
      query: {
        without_postprocessing?: boolean;
        pipeline_index: number;
        confidence_min?: number;
        confidence_max?: number;
        label?: string[];
        prediction?: string[];
        extreme_length?: components["schemas"]["SmartTag"][];
        partial_syntax?: components["schemas"]["SmartTag"][];
        dissimilar?: components["schemas"]["SmartTag"][];
        almost_correct?: components["schemas"]["SmartTag"][];
        behavioral_testing?: components["schemas"]["SmartTag"][];
        pipeline_comparison?: components["schemas"]["SmartTag"][];
        uncertain?: components["schemas"]["SmartTag"][];
        data_action?: components["schemas"]["DataAction"][];
        outcome?: components["schemas"]["OutcomeName"][];
        utterance?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["TopWordsResponse"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get confusion matrix on specified filters. */
  get_confusion_matrix_dataset_splits__dataset_split_name__confusion_matrix_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
      query: {
        without_postprocessing?: boolean;
        normalize?: boolean;
        reorder_classes?: boolean;
        pipeline_index: number;
        confidence_min?: number;
        confidence_max?: number;
        label?: string[];
        prediction?: string[];
        extreme_length?: components["schemas"]["SmartTag"][];
        partial_syntax?: components["schemas"]["SmartTag"][];
        dissimilar?: components["schemas"]["SmartTag"][];
        almost_correct?: components["schemas"]["SmartTag"][];
        behavioral_testing?: components["schemas"]["SmartTag"][];
        pipeline_comparison?: components["schemas"]["SmartTag"][];
        uncertain?: components["schemas"]["SmartTag"][];
        data_action?: components["schemas"]["DataAction"][];
        outcome?: components["schemas"]["OutcomeName"][];
        utterance?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ConfusionMatrixResponse"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
}

export interface external {}
