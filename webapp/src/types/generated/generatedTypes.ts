/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/status": {
    /** Get the status of the app */
    get: operations["get_status_status_get"];
  };
  "/dataset_info": {
    /** Get the current dataset info */
    get: operations["get_dataset_info_dataset_info_get"];
  };
  "/custom_metrics_info": {
    /** Gives the description of all custom metrics. */
    get: operations["custom_metrics_info_custom_metrics_info_get"];
  };
  "/perturbation_testing_summary": {
    /** Get a failure rate per dataset split and per test as well. */
    get: operations["get_perturbation_testing_summary_perturbation_testing_summary_get"];
  };
  "/admin/config": {
    /** Get the current configuration */
    get: operations["get_config_def_admin_config_get"];
    /** Update the config using a changeset. */
    patch: operations["update_config_admin_config_patch"];
  };
  "/tags": {
    /** Post new data_action tags */
    post: operations["post_data_actions_tags_post"];
  };
  "/dataset_splits/{dataset_split_name}/confidence_histogram": {
    /** Get all confidence bins with their confidence and the outcome count */
    get: operations["get_confidence_histogram_dataset_splits__dataset_split_name__confidence_histogram_get"];
  };
  "/dataset_warnings": {
    /** Get the warnings related to the dataset, such as differences between the training and the evaluation set. */
    get: operations["get_dataset_warnings_dataset_warnings_get"];
  };
  "/dataset_splits/{dataset_split_name}/metrics": {
    /** Get metrics (ECE, outcome count, precision and so on). */
    get: operations["get_metrics_dataset_splits__dataset_split_name__metrics_get"];
  };
  "/dataset_splits/{dataset_split_name}/metrics/per_filter": {
    /** Get metrics for each filter based on the current filtering. */
    get: operations["get_metrics_per_filter_dataset_splits__dataset_split_name__metrics_per_filter_get"];
  };
  "/dataset_splits/{dataset_split_name}/outcome_count/per_threshold": {
    /** Get prediction count per outcome for multiple thresholds. */
    get: operations["get_outcome_count_per_threshold_dataset_splits__dataset_split_name__outcome_count_per_threshold_get"];
  };
  "/dataset_splits/{dataset_split_name}/outcome_count/per_filter": {
    /** Get outcome count for each filter based on the current filtering. */
    get: operations["get_outcome_count_per_filter_dataset_splits__dataset_split_name__outcome_count_per_filter_get"];
  };
  "/dataset_splits/{dataset_split_name}/utterance_count/per_filter": {
    /** Get count for each filter based on the current filtering. */
    get: operations["get_count_per_filter_dataset_splits__dataset_split_name__utterance_count_per_filter_get"];
  };
  "/dataset_splits/{dataset_split_name}/utterances": {
    /** Get a table view of the utterances according to filters. */
    get: operations["get_utterances_dataset_splits__dataset_split_name__utterances_get"];
  };
  "/dataset_splits/{dataset_split_name}/utterances/{index}/perturbed_utterances": {
    /** Get a perturbed utterances for a single utterance. */
    get: operations["get_perturbed_utterances_dataset_splits__dataset_split_name__utterances__index__perturbed_utterances_get"];
  };
  "/dataset_splits/{dataset_split_name}/utterances/{index}/similar_utterances": {
    /** Get similar examples using a KNN approach. */
    get: operations["get_similar_dataset_splits__dataset_split_name__utterances__index__similar_utterances_get"];
  };
  "/export/dataset_splits/{dataset_split_name}/utterances": {
    /** Export the dataset_split to a CSV file and returns it. */
    get: operations["export_dataset_export_dataset_splits__dataset_split_name__utterances_get"];
  };
  "/export/perturbation_testing_summary": {
    /** Export the perturbation testing summary to a CSV file and returns it. */
    get: operations["get_export_perturbation_testing_summary_export_perturbation_testing_summary_get"];
  };
  "/export/dataset_splits/{dataset_split_name}/perturbed_utterances": {
    /** Export the perturbed dataset split (training or evaluation) to a JSON file and returns it. */
    get: operations["get_export_perturbed_set_export_dataset_splits__dataset_split_name__perturbed_utterances_get"];
  };
  "/custom_utterances/perturbed_utterances": {
    /** Get perturbed utterances based on custom utterances. */
    get: operations["get_perturbed_utterances_custom_utterances_perturbed_utterances_get"];
  };
  "/custom_utterances/saliency": {
    /** Get saliency for custom utterances. */
    get: operations["get_saliency_custom_utterances_saliency_get"];
  };
  "/dataset_splits/{dataset_split_name}/top_words": {
    /** Get most important words for right predictions and errors based on filters. */
    get: operations["get_top_words_dataset_splits__dataset_split_name__top_words_get"];
  };
  "/dataset_splits/{dataset_split_name}/confusion_matrix": {
    /** Get confusion matrix on specified filters. */
    get: operations["get_confusion_matrix_dataset_splits__dataset_split_name__confusion_matrix_get"];
  };
}

export interface components {
  schemas: {
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    AvailableDatasetSplits: {
      train: boolean;
      eval: boolean;
    };
    /** Fields that can be modified without affecting caching. */
    AzimuthConfig: {
      name?: string;
      dataset: components["schemas"]["CustomObject"];
      model_contract?: components["schemas"]["SupportedModelContract"];
      columns?: components["schemas"]["ColumnConfiguration"];
      rejection_class?: string;
      artifact_path?: string;
      batch_size?: number;
      use_cuda?: Partial<"auto"> & Partial<boolean>;
      syntax?: components["schemas"]["SyntaxOptions"];
      dataset_warnings?: components["schemas"]["DatasetWarningsOptions"];
      similarity?: components["schemas"]["SimilarityOptions"];
      pipelines?: components["schemas"]["PipelineDefinition"][];
      uncertainty?: components["schemas"]["UncertaintyOptions"];
      saliency_layer?: string;
      metrics?: { [key: string]: components["schemas"]["MetricDefinition"] };
      behavioral_testing?: components["schemas"]["BehavioralTestingOptions"];
    };
    BehavioralTestingOptions: {
      neutral_token?: components["schemas"]["NeutralTokenOptions"];
      punctuation?: components["schemas"]["PunctuationTestOptions"];
      fuzzy_matching?: components["schemas"]["FuzzyMatchingTestOptions"];
      typo?: components["schemas"]["TypoTestOptions"];
      seed?: number;
    };
    ColumnConfiguration: {
      text_input?: string;
      raw_text_input?: string;
      label?: string;
      failed_parsing_reason?: string;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    ConfidenceBinDetails: {
      binIndex: number;
      binConfidence: number;
      meanBinConfidence: number;
      outcomeCount: { [key: string]: number };
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    ConfidenceHistogramResponse: {
      bins: components["schemas"]["ConfidenceBinDetails"][];
      confidenceThreshold: number | null;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    ConfusionMatrixResponse: {
      confusionMatrix: { [key: string]: any };
      classNames: string[];
      normalize: boolean;
      preserveClassOrder: boolean;
      rejectionClassPosition: number;
    };
    CustomObject: {
      class_name: string;
      args?: (Partial<components["schemas"]["CustomObject"]> &
        Partial<{ [key: string]: any }>)[];
      kwargs?: {
        [key: string]: Partial<components["schemas"]["CustomObject"]> &
          Partial<{ [key: string]: any }>;
      };
      /** Relative path to class. `class` needs to be accessible from this path. */
      remote?: string;
    };
    /** An enumeration. */
    DataAction:
      | "relabel"
      | "augment_with_similar"
      | "define_new_class"
      | "merge_classes"
      | "remove"
      | "investigate"
      | "NO_ACTION";
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    DataActionMapping: {
      relabel: boolean;
      augmentWithSimilar: boolean;
      defineNewClass: boolean;
      mergeClasses: boolean;
      remove: boolean;
      investigate: boolean;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    DataActionResponse: {
      dataActions: components["schemas"]["DataActionMapping"][];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    DatasetDistributionComparison: {
      name: string;
      alert: boolean;
      data: components["schemas"]["DatasetDistributionComparisonValue"][];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    DatasetDistributionComparisonValue: {
      value: (Partial<number> & Partial<number>) | null;
      alert: boolean;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    DatasetInfoResponse: {
      projectName: string;
      classNames: string[];
      dataActions: components["schemas"]["DataAction"][];
      smartTags: components["schemas"]["SmartTag"][];
      evalClassDistribution: number[];
      trainClassDistribution: number[];
      startupTasks: { [key: string]: any };
      modelContract: components["schemas"]["SupportedModelContract"];
      predictionAvailable: boolean;
      perturbationTestingAvailable: boolean;
      availableDatasetSplits: components["schemas"]["AvailableDatasetSplits"];
      similarityAvailable: boolean;
      postprocessingEditable: boolean[] | null;
    };
    /** An enumeration. */
    DatasetSplitName: "eval" | "train" | "all";
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    DatasetWarning: {
      name: string;
      description: string;
      columns: string[];
      format: components["schemas"]["FormatType"];
      comparisons: components["schemas"]["DatasetDistributionComparison"][];
      plots: components["schemas"]["DatasetWarningPlots"];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    DatasetWarningGroup: {
      name: string;
      warnings: components["schemas"]["DatasetWarning"][];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    DatasetWarningPlots: {
      overall: components["schemas"]["PlotSpecification"];
      perClass: {
        [key: string]: components["schemas"]["PlotSpecification"];
      } | null;
    };
    DatasetWarningsOptions: {
      min_num_per_class?: number;
      max_delta_representation?: number;
      max_delta_mean_tokens?: number;
      max_delta_std_tokens?: number;
    };
    /** An enumeration. */
    FormatType: "Integer" | "Percentage" | "Decimal";
    FuzzyMatchingTestOptions: {
      threshold?: number;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    GetUtterancesResponse: {
      utterances: components["schemas"]["Utterance"][];
      utteranceCount: number;
      confidenceThreshold: number | null;
    };
    HTTPValidationError: {
      detail?: components["schemas"]["ValidationError"][];
    };
    MetricDefinition: {
      class_name: string;
      args?: (Partial<components["schemas"]["CustomObject"]> &
        Partial<{ [key: string]: any }>)[];
      kwargs?: {
        [key: string]: Partial<components["schemas"]["CustomObject"]> &
          Partial<{ [key: string]: any }>;
      };
      /** Relative path to class. `class` needs to be accessible from this path. */
      remote?: string;
      /** Keyword arguments supplied to `compute`. */
      additional_kwargs?: { [key: string]: any };
    };
    MetricInfo: {
      description: string;
      citation: string;
      features: { [key: string]: any };
      inputs_description: string;
      homepage: string;
      license: string;
      codebase_urls: string[];
      reference_urls: string[];
      streamable?: boolean;
      format?: string;
      metric_name?: string;
      config_name?: string;
      experiment_id?: string;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    MetricsAPIResponse: {
      outcomeCount: { [key: string]: number };
      utteranceCount: number;
      customMetrics: { [key: string]: number };
      ece: number;
      ecePlot: components["schemas"]["PlotSpecification"] | null;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    MetricsPerFilter: {
      almostCorrect: components["schemas"]["MetricsPerFilterValue"][];
      behavioralTesting: components["schemas"]["MetricsPerFilterValue"][];
      pipelineComparison: components["schemas"]["MetricsPerFilterValue"][];
      uncertain: components["schemas"]["MetricsPerFilterValue"][];
      prediction: components["schemas"]["MetricsPerFilterValue"][];
      outcome: components["schemas"]["MetricsPerFilterValue"][];
      extremeLength: components["schemas"]["MetricsPerFilterValue"][];
      partialSyntax: components["schemas"]["MetricsPerFilterValue"][];
      dissimilar: components["schemas"]["MetricsPerFilterValue"][];
      label: components["schemas"]["MetricsPerFilterValue"][];
      dataAction: components["schemas"]["MetricsPerFilterValue"][];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    MetricsPerFilterAPIResponse: {
      metricsPerFilter: components["schemas"]["MetricsPerFilter"];
      utteranceCount: number;
      metricsOverall: components["schemas"]["MetricsPerFilterValue"][];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    MetricsPerFilterValue: {
      utteranceCount: number;
      filterValue: string;
      outcomeCount: { [key: string]: number };
      customMetrics: { [key: string]: number };
      ece: number;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    ModelPrediction: {
      modelPredictions: string[];
      postprocessedPrediction: string;
      modelConfidences: number[];
      postprocessedConfidences: number[];
      modelOutcome: components["schemas"]["OutcomeName"];
      postprocessedOutcome: components["schemas"]["OutcomeName"];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    ModelSaliency: {
      tokens: string[];
      saliencies: number[];
    };
    NeutralTokenOptions: {
      threshold?: number;
      suffix_list?: string[];
      prefix_list?: string[];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    OutcomeCountPerFilter: {
      almostCorrect: components["schemas"]["OutcomeCountPerFilterValue"][];
      behavioralTesting: components["schemas"]["OutcomeCountPerFilterValue"][];
      pipelineComparison: components["schemas"]["OutcomeCountPerFilterValue"][];
      uncertain: components["schemas"]["OutcomeCountPerFilterValue"][];
      prediction: components["schemas"]["OutcomeCountPerFilterValue"][];
      outcome: components["schemas"]["OutcomeCountPerFilterValue"][];
      extremeLength: components["schemas"]["OutcomeCountPerFilterValue"][];
      partialSyntax: components["schemas"]["OutcomeCountPerFilterValue"][];
      dissimilar: components["schemas"]["OutcomeCountPerFilterValue"][];
      label: components["schemas"]["OutcomeCountPerFilterValue"][];
      dataAction: components["schemas"]["OutcomeCountPerFilterValue"][];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    OutcomeCountPerFilterResponse: {
      countPerFilter: components["schemas"]["OutcomeCountPerFilter"];
      utteranceCount: number;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    OutcomeCountPerFilterValue: {
      utteranceCount: number;
      filterValue: string;
      outcomeCount: { [key: string]: number };
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    OutcomeCountPerThresholdValue: {
      threshold: number;
      outcomeCount: { [key: string]: number };
    };
    /** An enumeration. */
    OutcomeName:
      | "CorrectAndPredicted"
      | "CorrectAndRejected"
      | "IncorrectAndPredicted"
      | "IncorrectAndRejected";
    /** An enumeration. */
    PerturbationTestFailureReason:
      | "Different predicted class."
      | "Confidence too far from original."
      | "NA";
    /** An enumeration. */
    PerturbationTestFamily: "Fuzzy Matching" | "Punctuation";
    /** An enumeration. */
    PerturbationTestName:
      | "Neutral Token"
      | "Question Mark"
      | "Ending Period"
      | "Inner Comma"
      | "Inner Period"
      | "Typos"
      | "Contractions";
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    PerturbationTestSummary: {
      name: components["schemas"]["PerturbationTestName"];
      description: string;
      family: components["schemas"]["PerturbationTestFamily"];
      perturbationType: components["schemas"]["PerturbationType"];
      evalFailureRate: number;
      evalCount: number;
      evalFailedCount: number;
      evalConfidenceDelta: number;
      trainFailureRate: number;
      trainCount: number;
      trainFailedCount: number;
      trainConfidenceDelta: number;
      example: components["schemas"]["PerturbedUtteranceExample"];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    PerturbationTestingSummary: {
      allTestsSummary: components["schemas"]["PerturbationTestSummary"][];
      failureRates: { [key: string]: number };
    };
    /** An enumeration. */
    PerturbationType:
      | "PreInsertion"
      | "PostInsertion"
      | "Deletion"
      | "Insertion"
      | "Replacement"
      | "Swap"
      | "Expansion"
      | "Contraction";
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    PerturbedUtteranceExample: {
      utterance: string;
      perturbedUtterance: string;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    PerturbedUtteranceWithClassNames: {
      name: components["schemas"]["PerturbationTestName"];
      description: string;
      family: components["schemas"]["PerturbationTestFamily"];
      perturbedUtterance: string;
      perturbations: string[];
      perturbationType: components["schemas"]["PerturbationType"];
      confidence: number;
      confidenceDelta: number | null;
      failed: boolean;
      failureReason: components["schemas"]["PerturbationTestFailureReason"];
      prediction: string;
    };
    /**
     * Base class for settings, allowing values to be overridden by environment variables.
     *
     * This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),
     * Heroku and any 12 factor app design.
     */
    PipelineDefinition: {
      name: string;
      model: components["schemas"]["CustomObject"];
      postprocessors?: (Partial<components["schemas"]["TemperatureScaling"]> &
        Partial<components["schemas"]["ThresholdConfig"]> &
        Partial<components["schemas"]["CustomObject"]>)[];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    PlotSpecification: {
      data: { [key: string]: any }[];
      layout: { [key: string]: any };
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    PostDataActionRequest: {
      datasetSplitName?: components["schemas"]["DatasetSplitName"];
      dataActions: { [key: string]: { [key: string]: boolean } };
    };
    PunctuationTestOptions: {
      threshold?: number;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    SaliencyResponse: {
      saliency: number[];
      tokens: string[];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    SimilarUtterance: {
      index: number;
      utterance: string;
      label: string;
      postprocessedPrediction: string | null;
      postprocessedConfidence: number | null;
      similarity: number;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    SimilarUtterancesResponse: {
      utterances: components["schemas"]["SimilarUtterance"][];
    };
    SimilarityOptions: {
      faiss_encoder?: string;
      conflicting_neighbors_threshold?: number;
      no_close_threshold?: number;
    };
    /** An enumeration. */
    SmartTag:
      | "multiple_sentences"
      | "long_sentence"
      | "short_sentence"
      | "missing_subj"
      | "missing_obj"
      | "missing_verb"
      | "conflicting_neighbors_train"
      | "conflicting_neighbors_eval"
      | "no_close_train"
      | "no_close_eval"
      | "failed_punctuation"
      | "failed_fuzzy_matching"
      | "high_epistemic_uncertainty"
      | "correct_top_3"
      | "correct_low_conf"
      | "incorrect_for_all_pipelines"
      | "pipeline_disagreement"
      | "NO_SMART_TAGS";
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    StatusResponse: {
      startupTasksReady: boolean;
      startupTasksStatus: { [key: string]: string };
    };
    /** An enumeration. */
    SupportedModelContract:
      | "hf_text_classification"
      | "file_based_text_classification"
      | "custom_text_classification";
    SyntaxOptions: {
      short_sentence_max_token?: number;
      long_sentence_min_token?: number;
    };
    /**
     * Base class for settings, allowing values to be overridden by environment variables.
     *
     * This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),
     * Heroku and any 12 factor app design.
     */
    TemperatureScaling: {
      class_name?: "azimuth.utils.ml.postprocessing.TemperatureScaling";
      args?: (Partial<components["schemas"]["CustomObject"]> &
        Partial<{ [key: string]: any }>)[];
      kwargs?: {
        [key: string]: Partial<components["schemas"]["CustomObject"]> &
          Partial<{ [key: string]: any }>;
      };
      /** Relative path to class. `class` needs to be accessible from this path. */
      remote?: string;
      temperature?: number;
    };
    /**
     * Base class for settings, allowing values to be overridden by environment variables.
     *
     * This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),
     * Heroku and any 12 factor app design.
     */
    ThresholdConfig: {
      class_name?: "azimuth.utils.ml.postprocessing.Thresholding";
      args?: (Partial<components["schemas"]["CustomObject"]> &
        Partial<{ [key: string]: any }>)[];
      kwargs?: {
        [key: string]: Partial<components["schemas"]["CustomObject"]> &
          Partial<{ [key: string]: any }>;
      };
      /** Relative path to class. `class` needs to be accessible from this path. */
      remote?: string;
      threshold?: number;
    };
    /** An enumeration. */
    TopWordsImportanceCriteria: "salient" | "frequent";
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    TopWordsResponse: {
      all: components["schemas"]["TopWordsResult"][];
      right: components["schemas"]["TopWordsResult"][];
      errors: components["schemas"]["TopWordsResult"][];
      importanceCriteria: components["schemas"]["TopWordsImportanceCriteria"];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    TopWordsResult: {
      word: string;
      count: number;
    };
    TypoTestOptions: {
      threshold?: number;
      nb_typos_per_utterance?: number;
    };
    UncertaintyOptions: {
      iterations?: number;
      high_epistemic_threshold?: number;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    Utterance: {
      almostCorrect: string[];
      behavioralTesting: string[];
      pipelineComparison: string[];
      uncertain: string[];
      extremeLength: string[];
      partialSyntax: string[];
      dissimilar: string[];
      /** Row index computed by Azimuth.. */
      index: number;
      modelPrediction: components["schemas"]["ModelPrediction"] | null;
      modelSaliency: components["schemas"]["ModelSaliency"] | null;
      dataAction: components["schemas"]["DataAction"];
      label: string;
      utterance: string;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    UtteranceCountPerFilter: {
      extremeLength: components["schemas"]["UtteranceCountPerFilterValue"][];
      partialSyntax: components["schemas"]["UtteranceCountPerFilterValue"][];
      dissimilar: components["schemas"]["UtteranceCountPerFilterValue"][];
      label: components["schemas"]["UtteranceCountPerFilterValue"][];
      dataAction: components["schemas"]["UtteranceCountPerFilterValue"][];
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    UtteranceCountPerFilterResponse: {
      countPerFilter: components["schemas"]["UtteranceCountPerFilter"];
      utteranceCount: number;
    };
    /**
     * This model should be used as the base for any model that defines aliases to ensure
     * that all fields are represented correctly.
     */
    UtteranceCountPerFilterValue: {
      utteranceCount: number;
      filterValue: string;
    };
    /** An enumeration. */
    UtterancesSortableColumn:
      | "index"
      | "utterance"
      | "label"
      | "prediction"
      | "confidence";
    ValidationError: {
      loc: string[];
      msg: string;
      type: string;
    };
  };
}

export interface operations {
  /** Get the status of the app */
  get_status_status_get: {
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["StatusResponse"];
        };
      };
    };
  };
  /** Get the current dataset info */
  get_dataset_info_dataset_info_get: {
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["DatasetInfoResponse"];
        };
      };
    };
  };
  /** Gives the description of all custom metrics. */
  custom_metrics_info_custom_metrics_info_get: {
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": {
            [key: string]: components["schemas"]["MetricInfo"];
          };
        };
      };
    };
  };
  /** Get a failure rate per dataset split and per test as well. */
  get_perturbation_testing_summary_perturbation_testing_summary_get: {
    parameters: {
      query: {
        pipeline_index: number;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PerturbationTestingSummary"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get the current configuration */
  get_config_def_admin_config_get: {
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["AzimuthConfig"];
        };
      };
    };
  };
  /** Update the config using a changeset. */
  update_config_admin_config_patch: {
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["AzimuthConfig"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": { [key: string]: any };
      };
    };
  };
  /** Post new data_action tags */
  post_data_actions_tags_post: {
    parameters: {
      query: {
        pipeline_index?: number;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["DataActionResponse"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PostDataActionRequest"];
      };
    };
  };
  /** Get all confidence bins with their confidence and the outcome count */
  get_confidence_histogram_dataset_splits__dataset_split_name__confidence_histogram_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
      query: {
        without_postprocessing?: boolean;
        pipeline_index: number;
        confidence_min?: number;
        confidence_max?: number;
        label?: string[];
        prediction?: string[];
        extreme_length?: components["schemas"]["SmartTag"][];
        partial_syntax?: components["schemas"]["SmartTag"][];
        dissimilar?: components["schemas"]["SmartTag"][];
        almost_correct?: components["schemas"]["SmartTag"][];
        behavioral_testing?: components["schemas"]["SmartTag"][];
        pipeline_comparison?: components["schemas"]["SmartTag"][];
        uncertain?: components["schemas"]["SmartTag"][];
        data_action?: components["schemas"]["DataAction"][];
        outcome?: components["schemas"]["OutcomeName"][];
        utterance?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ConfidenceHistogramResponse"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get the warnings related to the dataset, such as differences between the training and the evaluation set. */
  get_dataset_warnings_dataset_warnings_get: {
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["DatasetWarningGroup"][];
        };
      };
    };
  };
  /** Get metrics (ECE, outcome count, precision and so on). */
  get_metrics_dataset_splits__dataset_split_name__metrics_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
      query: {
        without_postprocessing?: boolean;
        pipeline_index: number;
        confidence_min?: number;
        confidence_max?: number;
        label?: string[];
        prediction?: string[];
        extreme_length?: components["schemas"]["SmartTag"][];
        partial_syntax?: components["schemas"]["SmartTag"][];
        dissimilar?: components["schemas"]["SmartTag"][];
        almost_correct?: components["schemas"]["SmartTag"][];
        behavioral_testing?: components["schemas"]["SmartTag"][];
        pipeline_comparison?: components["schemas"]["SmartTag"][];
        uncertain?: components["schemas"]["SmartTag"][];
        data_action?: components["schemas"]["DataAction"][];
        outcome?: components["schemas"]["OutcomeName"][];
        utterance?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["MetricsAPIResponse"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get metrics for each filter based on the current filtering. */
  get_metrics_per_filter_dataset_splits__dataset_split_name__metrics_per_filter_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
      query: {
        pipeline_index: number;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["MetricsPerFilterAPIResponse"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get prediction count per outcome for multiple thresholds. */
  get_outcome_count_per_threshold_dataset_splits__dataset_split_name__outcome_count_per_threshold_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
      query: {
        pipeline_index: number;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["OutcomeCountPerThresholdValue"][];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get outcome count for each filter based on the current filtering. */
  get_outcome_count_per_filter_dataset_splits__dataset_split_name__outcome_count_per_filter_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
      query: {
        without_postprocessing?: boolean;
        pipeline_index: number;
        confidence_min?: number;
        confidence_max?: number;
        label?: string[];
        prediction?: string[];
        extreme_length?: components["schemas"]["SmartTag"][];
        partial_syntax?: components["schemas"]["SmartTag"][];
        dissimilar?: components["schemas"]["SmartTag"][];
        almost_correct?: components["schemas"]["SmartTag"][];
        behavioral_testing?: components["schemas"]["SmartTag"][];
        pipeline_comparison?: components["schemas"]["SmartTag"][];
        uncertain?: components["schemas"]["SmartTag"][];
        data_action?: components["schemas"]["DataAction"][];
        outcome?: components["schemas"]["OutcomeName"][];
        utterance?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["OutcomeCountPerFilterResponse"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get count for each filter based on the current filtering. */
  get_count_per_filter_dataset_splits__dataset_split_name__utterance_count_per_filter_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
      query: {
        confidence_min?: number;
        confidence_max?: number;
        label?: string[];
        prediction?: string[];
        extreme_length?: components["schemas"]["SmartTag"][];
        partial_syntax?: components["schemas"]["SmartTag"][];
        dissimilar?: components["schemas"]["SmartTag"][];
        almost_correct?: components["schemas"]["SmartTag"][];
        behavioral_testing?: components["schemas"]["SmartTag"][];
        pipeline_comparison?: components["schemas"]["SmartTag"][];
        uncertain?: components["schemas"]["SmartTag"][];
        data_action?: components["schemas"]["DataAction"][];
        outcome?: components["schemas"]["OutcomeName"][];
        utterance?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UtteranceCountPerFilterResponse"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get a table view of the utterances according to filters. */
  get_utterances_dataset_splits__dataset_split_name__utterances_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
      query: {
        indices?: number[];
        sort?: components["schemas"]["UtterancesSortableColumn"];
        descending?: boolean;
        without_postprocessing?: boolean;
        confidence_min?: number;
        confidence_max?: number;
        label?: string[];
        prediction?: string[];
        extreme_length?: components["schemas"]["SmartTag"][];
        partial_syntax?: components["schemas"]["SmartTag"][];
        dissimilar?: components["schemas"]["SmartTag"][];
        almost_correct?: components["schemas"]["SmartTag"][];
        behavioral_testing?: components["schemas"]["SmartTag"][];
        pipeline_comparison?: components["schemas"]["SmartTag"][];
        uncertain?: components["schemas"]["SmartTag"][];
        data_action?: components["schemas"]["DataAction"][];
        outcome?: components["schemas"]["OutcomeName"][];
        utterance?: string;
        pipeline_index?: number;
        limit?: number;
        offset?: number;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["GetUtterancesResponse"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get a perturbed utterances for a single utterance. */
  get_perturbed_utterances_dataset_splits__dataset_split_name__utterances__index__perturbed_utterances_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
        index: number;
      };
      query: {
        pipeline_index: number;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PerturbedUtteranceWithClassNames"][];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get similar examples using a KNN approach. */
  get_similar_dataset_splits__dataset_split_name__utterances__index__similar_utterances_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
        index: number;
      };
      query: {
        limit?: number;
        neighbors_dataset_split_name?: components["schemas"]["DatasetSplitName"];
        pipeline_index?: number;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["SimilarUtterancesResponse"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Export the dataset_split to a CSV file and returns it. */
  export_dataset_export_dataset_splits__dataset_split_name__utterances_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
      query: {
        pipeline_index?: number;
      };
    };
    responses: {
      /** Successful Response */
      200: unknown;
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Export the perturbation testing summary to a CSV file and returns it. */
  get_export_perturbation_testing_summary_export_perturbation_testing_summary_get: {
    parameters: {
      query: {
        pipeline_index: number;
      };
    };
    responses: {
      /** Successful Response */
      200: unknown;
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Export the perturbed dataset split (training or evaluation) to a JSON file and returns it. */
  get_export_perturbed_set_export_dataset_splits__dataset_split_name__perturbed_utterances_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
      query: {
        pipeline_index: number;
      };
    };
    responses: {
      /** Successful Response */
      200: unknown;
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get perturbed utterances based on custom utterances. */
  get_perturbed_utterances_custom_utterances_perturbed_utterances_get: {
    parameters: {
      query: {
        utterances?: string[];
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": { [key: string]: any };
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get saliency for custom utterances. */
  get_saliency_custom_utterances_saliency_get: {
    parameters: {
      query: {
        utterances?: string[];
        pipeline_index: number;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["SaliencyResponse"][];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get most important words for right predictions and errors based on filters. */
  get_top_words_dataset_splits__dataset_split_name__top_words_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
      query: {
        without_postprocessing?: boolean;
        pipeline_index: number;
        confidence_min?: number;
        confidence_max?: number;
        label?: string[];
        prediction?: string[];
        extreme_length?: components["schemas"]["SmartTag"][];
        partial_syntax?: components["schemas"]["SmartTag"][];
        dissimilar?: components["schemas"]["SmartTag"][];
        almost_correct?: components["schemas"]["SmartTag"][];
        behavioral_testing?: components["schemas"]["SmartTag"][];
        pipeline_comparison?: components["schemas"]["SmartTag"][];
        uncertain?: components["schemas"]["SmartTag"][];
        data_action?: components["schemas"]["DataAction"][];
        outcome?: components["schemas"]["OutcomeName"][];
        utterance?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["TopWordsResponse"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get confusion matrix on specified filters. */
  get_confusion_matrix_dataset_splits__dataset_split_name__confusion_matrix_get: {
    parameters: {
      path: {
        dataset_split_name: components["schemas"]["DatasetSplitName"];
      };
      query: {
        without_postprocessing?: boolean;
        normalize?: boolean;
        preserve_class_order?: boolean;
        pipeline_index: number;
        confidence_min?: number;
        confidence_max?: number;
        label?: string[];
        prediction?: string[];
        extreme_length?: components["schemas"]["SmartTag"][];
        partial_syntax?: components["schemas"]["SmartTag"][];
        dissimilar?: components["schemas"]["SmartTag"][];
        almost_correct?: components["schemas"]["SmartTag"][];
        behavioral_testing?: components["schemas"]["SmartTag"][];
        pipeline_comparison?: components["schemas"]["SmartTag"][];
        uncertain?: components["schemas"]["SmartTag"][];
        data_action?: components["schemas"]["DataAction"][];
        outcome?: components["schemas"]["OutcomeName"][];
        utterance?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ConfusionMatrixResponse"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
}

export interface external {}
